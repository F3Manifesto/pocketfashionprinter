'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var debug = require('debug')('json-immutable');
var immutable = require('immutable');

var JSONStreamStringify = require('json-stream-stringify');

function deserialize(json) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return JSON.parse(json, function (key, value) {
    return revive(key, value, options);
  });
}

function serialize(data) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (immutable.Iterable.isIterable(data) || data instanceof immutable.Record) {
    // NOTE: JSON.stringify() calls the #toJSON() method of the root object.
    //   Immutable.JS provides its own #toJSON() implementation which does not
    //   preserve map key types.
    data = Object.create(data);
    data.toJSON = function () {
      debug('#toJSON()', this);
      return this;
    };
  }

  var indentation = options.pretty ? 2 : 0;

  return JSON.stringify(data, replace, indentation);
}

function createSerializationStream(data) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var indentation = options.pretty ? 2 : 0;
  var replacer = options.bigChunks ? replace : replaceAsync;

  var stream = JSONStreamStringify(data, replacer, indentation);
  return stream;
}

function revive(key, value, options) {
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value) {
    if (value['__record']) {
      return reviveRecord(key, value, options);
    } else if (value['__iterable']) {
      return reviveIterable(key, value, options);
    }
  }
  return value;
}

function replace(key, value) {
  debug('key:', key);
  debug('value:', value);

  var result = value;

  if (value instanceof immutable.Record) {
    result = replaceRecord(value, replace);
  } else if (immutable.Iterable.isIterable(value)) {
    result = replaceIterable(value, replace);
  } else if (Array.isArray(value)) {
    result = replaceArray(value, replace);
  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {
    result = replacePlainObject(value, replace);
  }

  debug('result:', result, '\n---');
  return result;
}

function replaceAsync(key, value) {
  debug('key:', key);
  debug('value:', value);

  var result = value;

  if (!(value instanceof Promise)) {
    if (value instanceof immutable.Record) {
      result = new Promise(function (resolve) {
        setImmediate(function () {
          resolve(replaceRecord(value, replaceAsync));
        });
      });
    } else if (immutable.Iterable.isIterable(value)) {
      result = new Promise(function (resolve) {
        setImmediate(function () {
          resolve(replaceIterable(value, replaceAsync));
        });
      });
    } else if (Array.isArray(value)) {
      result = new Promise(function (resolve) {
        setImmediate(function () {
          resolve(replaceArray(value, replaceAsync));
        });
      });
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {
      result = new Promise(function (resolve) {
        setImmediate(function () {
          resolve(replacePlainObject(value, replaceAsync));
        });
      });
    }
  }

  debug('result:', result, '\n---');
  return result;
}

function reviveRecord(key, recInfo, options) {
  var RecordType = options.recordTypes[recInfo['__record']];
  if (!RecordType) {
    throw new Error('Unknown record type: ' + recInfo['__record']);
  }

  return RecordType(revive(key, recInfo['data'], options));
}

function replaceRecord(rec, replaceChild) {
  debug('replaceRecord()', rec);
  var recordDataMap = rec.toMap();
  var recordData = {};

  recordDataMap.forEach(function (value, key) {
    recordData[key] = replaceChild(key, value);
  });

  if (!rec._name) {
    return recordData;
  }
  return { "__record": rec._name, "data": recordData };
}

function reviveIterable(key, iterInfo, options) {
  switch (iterInfo['__iterable']) {
    case 'List':
      return immutable.List(revive(key, iterInfo['data'], options));

    case 'Set':
      return immutable.Set(revive(key, iterInfo['data'], options));

    case 'OrderedSet':
      return immutable.OrderedSet(revive(key, iterInfo['data'], options));

    case 'Stack':
      return immutable.Stack(revive(key, iterInfo['data'], options));

    case 'Map':
      return immutable.Map(revive(key, iterInfo['data'], options));

    case 'OrderedMap':
      return immutable.OrderedMap(revive(key, iterInfo['data'], options));

    default:
      throw new Error('Unknown iterable type: ' + iterInfo['__iterable']);
  }
}

function replaceIterable(iter, replaceChild) {
  debug('replaceIterable()', iter);

  var iterableType = iter.constructor.name;

  var _ret = function () {
    switch (iterableType) {
      case 'List':
      case 'Set':
      case 'OrderedSet':
      case 'Stack':
        var listData = [];
        iter.forEach(function (value, key) {
          listData.push(replaceChild(key, value));
        });
        return {
          v: { "__iterable": iterableType, "data": listData }
        };

      case 'Map':
      case 'OrderedMap':
        var mapData = [];
        iter.forEach(function (value, key) {
          mapData.push([key, replaceChild(key, value)]);
        });
        return {
          v: { "__iterable": iterableType, "data": mapData }
        };

      default:
        var iterData = {};
        iter.forEach(function (value, key) {
          iterData[key] = replaceChild(key, value);
        });
        return {
          v: { "__iterable": iterableType, "data": iterData }
        };
    }
  }();

  if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
}

function replaceArray(arr, replaceChild) {
  debug('replaceArray()', arr);

  return arr.map(function (value, index) {
    return replaceChild(index, value);
  });
}

function replacePlainObject(obj, replaceChild) {
  debug('replacePlainObject()', obj);

  var objData = {};
  Object.keys(obj).forEach(function (key) {
    objData[key] = replaceChild(key, obj[key]);
  });

  return objData;
}

module.exports = {
  createSerializationStream: createSerializationStream,
  deserialize: deserialize,
  serialize: serialize
};