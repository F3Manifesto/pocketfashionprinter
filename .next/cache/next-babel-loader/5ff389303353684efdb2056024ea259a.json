{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport { useSelector } from 'react-redux';\nimport { formatEther } from '@ethersproject/units';\nimport { getAccount } from '@selectors/user.selectors';\nimport { getChainId } from '@selectors/global.selectors';\nimport { getSelectedCrypto, getTicketPrice } from '@selectors/crypto.selectors';\nimport { getERC20TokenContract } from '@services/contract.service';\nimport config from '@utils/config';\nimport { POLYGON_CHAINID } from '@constants/global.constants';\nimport { useIsMainnet } from './useIsMainnet';\nimport usePollar from './usePollar';\nexport function useTokenAllowance() {\n  const {\n    0: allowance,\n    1: setAllowance\n  } = useState('0');\n  const account = useSelector(getAccount);\n  const isMainnet = useIsMainnet();\n  const chainId = useSelector(getChainId);\n  const selectedCrypto = useSelector(getSelectedCrypto);\n  const selectedCryptoRef = useRef(selectedCrypto);\n  selectedCryptoRef.current = selectedCrypto;\n  const targetAddress = config.PAYMENT_ACCEPT['matic'];\n  const fetchAllowance = useCallback(async () => {\n    // Only Polygon is acceptable\n    // Currently we support only Mona and wEth tokens\n    if (account && chainId && chainId == POLYGON_CHAINID) {\n      if (selectedCryptoRef.current === 'matic') {\n        setAllowance(await '10000000000');\n      } else {\n        // get ERC20 Token contract\n        const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId);\n\n        try {\n          contract && setAllowance(formatEther(await contract.methods.allowance(account, targetAddress).call({\n            from: account\n          })));\n        } catch (e) {\n          console.log({\n            e\n          });\n          throw e;\n        }\n      }\n    }\n  }, [account, chainId]);\n  fetchAllowance();\n  usePollar(fetchAllowance);\n  return allowance;\n}\nexport default function useERC20Approve(amount) {\n  const account = useSelector(getAccount);\n  const chainId = useSelector(getChainId);\n  const selectedCrypto = useSelector(getSelectedCrypto);\n  console.log('config2: ', config);\n  const targetAddress = config.PAYMENT_ACCEPT['matic'];\n  const {\n    0: approved,\n    1: setApproved\n  } = useState(false);\n  const allowance = useTokenAllowance();\n  useEffect(() => {\n    console.log('allowance: ', parseFloat(allowance));\n    console.log('amount: ', parseFloat(amount));\n\n    if (selectedCrypto && parseFloat(allowance) >= 10000000000) {\n      setApproved(true);\n    } else {\n      setApproved(false);\n    }\n  }, [amount, allowance, selectedCrypto]);\n  const isMainnet = useIsMainnet();\n  const selectedCryptoRef = useRef(selectedCrypto);\n  selectedCryptoRef.current = selectedCrypto;\n\n  const approveFunc = async () => {\n    if (account && chainId) {\n      // get ERC20 Token contract\n      const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId);\n\n      try {\n        contract && (await contract.methods.approve(targetAddress, amount).send({\n          from: account\n        }));\n      } catch (e) {\n        console.log({\n          e\n        });\n        throw e;\n      }\n    }\n  }; // sendAmount should be calculated as actual price before calling this function\n\n\n  const sendCrypto = async sendAmount => {\n    // if (\n    //   selectedCrypto != 'mona' && \n    //   selectedCrypto != 'weth' && \n    //   selectedCrypto != 'usdt' && \n    //   selectedCrypto != 'w3f' && \n    //   selectedCrypto != 'matic' && \n    //   selectedCrypto != 'dai'\n    // ) return\n    const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId);\n\n    try {\n      const listener = contract.methods.transfer(targetAddress, sendAmount).send({\n        from: account\n      });\n      const promise = new Promise((resolve, reject) => {\n        listener.on('error', error => reject(error));\n        listener.on('confirmation', transactionHash => resolve(transactionHash));\n      });\n      console.log('listener: ', listener);\n      return {\n        promise,\n        unsubscribe: () => {\n          listener.off('error');\n          listener.off('confirmation');\n        }\n      };\n    } catch (e) {\n      console.log({\n        e\n      });\n      throw e;\n    }\n  };\n\n  console.log('selectedCrypto: ', selectedCrypto);\n  console.log('approved: ', approved);\n  return {\n    approved,\n    approveFunc,\n    sendCrypto\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useSelector","formatEther","getAccount","getChainId","getSelectedCrypto","getTicketPrice","getERC20TokenContract","config","POLYGON_CHAINID","useIsMainnet","usePollar","useTokenAllowance","allowance","setAllowance","account","isMainnet","chainId","selectedCrypto","selectedCryptoRef","current","targetAddress","PAYMENT_ACCEPT","fetchAllowance","contract","methods","call","from","e","console","log","useERC20Approve","amount","approved","setApproved","parseFloat","approveFunc","approve","send","sendCrypto","sendAmount","listener","transfer","promise","Promise","resolve","reject","on","error","transactionHash","unsubscribe","off"],"sources":["/Volumes/Data/Work/Digitalax/PFPMint/src/hooks/useERC20Approve.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport { useSelector } from 'react-redux'\n\nimport { formatEther } from '@ethersproject/units'\n\nimport { getAccount } from '@selectors/user.selectors'\nimport { getChainId } from '@selectors/global.selectors'\nimport {\n  getSelectedCrypto,\n  getTicketPrice\n} from '@selectors/crypto.selectors'\n\nimport {\n  getERC20TokenContract\n} from '@services/contract.service'\n\nimport config from '@utils/config'\n\nimport { POLYGON_CHAINID } from '@constants/global.constants'\n\nimport { useIsMainnet } from './useIsMainnet'\nimport usePollar from './usePollar'\n\nexport function useTokenAllowance() {\n  const [allowance, setAllowance] = useState('0')\n  const account = useSelector(getAccount)\n  const isMainnet = useIsMainnet()\n  const chainId = useSelector(getChainId)\n  const selectedCrypto = useSelector(getSelectedCrypto)\n\n  const selectedCryptoRef = useRef(selectedCrypto)\n  selectedCryptoRef.current = selectedCrypto\n\n  const targetAddress = config.PAYMENT_ACCEPT['matic']\n\n  const fetchAllowance = useCallback(async () => {\n    // Only Polygon is acceptable\n    // Currently we support only Mona and wEth tokens\n    if (account && chainId && chainId == POLYGON_CHAINID) {\n\n      if (selectedCryptoRef.current === 'matic') {\n        setAllowance(await '10000000000')\n      } else {\n        // get ERC20 Token contract\n        const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId)\n\n        try {\n          contract && setAllowance(\n            formatEther(\n              await contract.methods.allowance(account, targetAddress).call({ from: account })\n            )\n          )\n        } catch (e) {\n          console.log({ e });\n          throw e;\n        }\n      }\n    }\n  }, [account, chainId])\n\n  fetchAllowance()\n  usePollar(fetchAllowance)\n\n  return allowance\n}\n\nexport default function useERC20Approve(amount) {\n  const account = useSelector(getAccount)\n  const chainId = useSelector(getChainId)\n  const selectedCrypto = useSelector(getSelectedCrypto)\n  console.log('config2: ', config)\n  const targetAddress = config.PAYMENT_ACCEPT['matic']\n\n  const [approved, setApproved] = useState(false)\n\n  const allowance = useTokenAllowance()\n\n  useEffect(() => {\n    console.log('allowance: ', parseFloat(allowance))\n    console.log('amount: ', parseFloat(amount))\n\n    if (selectedCrypto && parseFloat(allowance) >= 10000000000) {\n      setApproved(true)\n    } else {\n      setApproved(false)\n    }\n  }, [amount, allowance, selectedCrypto])\n\n  const isMainnet = useIsMainnet()\n\n  const selectedCryptoRef = useRef(selectedCrypto)\n  selectedCryptoRef.current = selectedCrypto\n\n  const approveFunc = async () => {\n    if (account && chainId) {\n      // get ERC20 Token contract\n      const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId)\n\n      try {\n        contract && await contract.methods.approve(targetAddress, amount).send({ from: account });\n      } catch (e) {\n        console.log({ e });\n        throw e;\n      }      \n    }\n  }\n\n  // sendAmount should be calculated as actual price before calling this function\n\n  const sendCrypto = async (sendAmount) => {\n    // if (\n    //   selectedCrypto != 'mona' && \n    //   selectedCrypto != 'weth' && \n    //   selectedCrypto != 'usdt' && \n    //   selectedCrypto != 'w3f' && \n    //   selectedCrypto != 'matic' && \n    //   selectedCrypto != 'dai'\n    // ) return\n\n    const contract = await getERC20TokenContract(selectedCryptoRef.current, chainId)\n\n    try {\n      const listener = contract.methods\n        .transfer(targetAddress, sendAmount)\n        .send({ from: account })\n\n      const promise = new Promise((resolve, reject) => {\n        listener.on('error', (error) => reject(error))\n        listener.on('confirmation', (transactionHash) => resolve(transactionHash))\n      })\n\n      console.log('listener: ', listener)\n  \n      return {\n        promise,\n        unsubscribe: () => {\n          listener.off('error')\n          listener.off('confirmation')\n        },\n      }\n    } catch (e) {\n      console.log({ e })\n      throw e\n    }\n  }\n\n  console.log('selectedCrypto: ', selectedCrypto)\n  console.log('approved: ', approved)\n  return { approved, approveFunc, sendCrypto }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}